/** @jsx createElement */
'use strict';

var _slicedToArray = require('babel-runtime/helpers/sliced-to-array')['default'];

var _extends = require('babel-runtime/helpers/extends')['default'];

var _Object$defineProperty = require('babel-runtime/core-js/object/define-property')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

var _interopRequireWildcard = require('babel-runtime/helpers/interop-require-wildcard')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.reconcile = reconcile;
exports.destroy = destroy;

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _elements = require('./elements');

var builtins = _interopRequireWildcard(_elements);

var _laconaPhrase = require('lacona-phrase');

function reconcile(_ref) {
  var descriptor = _ref.descriptor;
  var phrase = _ref.phrase;
  var options = _ref.options;

  var func = _lodash2['default'].isArray(descriptor) ? reconcileArray : reconcileOne;
  return func({ descriptor: descriptor, phrase: phrase, options: options });
}

function reconcileArray(_ref2) {
  var descriptor = _ref2.descriptor;
  var phrase = _ref2.phrase;
  var options = _ref2.options;

  return _lodash2['default'].chain(descriptor).reject(_lodash2['default'].isNull).reject(_lodash2['default'].isString).zip(phrase).map(function (_ref3) {
    var _ref32 = _slicedToArray(_ref3, 2);

    var descriptor = _ref32[0];
    var phrase = _ref32[1];
    return reconcile({ descriptor: descriptor, phrase: phrase, options: options });
  }).value();
}

function reconcileOne(_ref4) {
  var descriptor = _ref4.descriptor;
  var phrase = _ref4.phrase;
  var options = _ref4.options;

  if (descriptor == null && phrase) return destroy({ phrase: phrase, removeSource: options.removeSource });

  var Constructor = getConstructor({ Constructor: descriptor.Constructor });
  var props = getRealProps({ descriptor: descriptor, Constructor: Constructor });
  var extensions = options.getExtensions(Constructor);

  if (phrase && phrase.constructor === Constructor && _lodash2['default'].isEqual(props, phrase.props)) {
    if (_lodash2['default'].some(phrase.__sources, function (obj) {
      return obj.lastVersion !== obj.source.__dataVersion;
    }) || !_lodash2['default'].isEqual(extensions, phrase.__oldExtensions)) {
      var describedPhrase = getDescribedPhrase({ Constructor: Constructor, phrase: phrase, extensions: extensions, options: options });

      phrase.__oldExtensions = extensions;
      phrase.__describedPhrase = describedPhrase;

      return phrase;
    } else {
      return phrase;
    }
  } else {
    if (phrase) destroy({ phrase: phrase, removeSource: options.removeSource });

    var newPhrase = new Constructor();
    newPhrase.props = props;

    var sourceCall = getCall({ prop: 'source', Constructor: Constructor, langs: options.langs });
    var sources = sourceCall ? sourceCall.call(newPhrase) : {};
    var allSources = _lodash2['default'].defaults({}, sources, Constructor.__additionalSources);
    applySources({ sources: allSources, phrase: newPhrase, getSource: options.getSource });

    create({ phrase: newPhrase });

    var describedPhrase = getDescribedPhrase({ Constructor: Constructor, phrase: newPhrase, extensions: extensions, options: options });

    newPhrase.__oldExtensions = extensions;
    newPhrase.__describedPhrase = describedPhrase;

    return newPhrase;
  }
}

function getDescribedPhrase(_ref5) {
  var phrase = _ref5.phrase;
  var extensions = _ref5.extensions;
  var options = _ref5.options;

  var describe = getCall({ prop: 'describe', Constructor: phrase.constructor, langs: options.langs });
  var description = getDescription({ describe: describe, extensions: extensions, phrase: phrase });
  return description ? reconcile({ descriptor: description, options: options, phrase: phrase.__describedPhrase }) : null;
}

function getCall(_ref6) {
  var Constructor = _ref6.Constructor;
  var langs = _ref6.langs;
  var prop = _ref6.prop;

  if (Constructor.prototype[prop]) {
    return Constructor.prototype[prop];
  } else if (Constructor.translations) {
    return getCallFromTranslations({ prop: prop, langs: langs, translations: Constructor.translations });
  }
}

function getCallFromTranslations(_ref7) {
  var prop = _ref7.prop;
  var langs = _ref7.langs;
  var translations = _ref7.translations;

  return _lodash2['default'].chain(langs.concat('default')).map(function (lang) {
    return _lodash2['default'].find(translations, function (obj) {
      return _lodash2['default'].includes(obj.langs, lang);
    });
  }).filter(_lodash2['default'].negate(_lodash2['default'].isUndefined)).first().value()[prop];
}
//
// function setPropsAndState({phrase, props, state, changed}) {
//   phrase.props = props
//
//   if (!phrase.setState) {
//     phrase.state = state || {}
//     phrase.setState = function (nextState) {
//       _.merge(this.state, nextState)
//       this._stateChanged = true
//       changed(this)
//     }
//   }
// }

function getDescription(_ref8) {
  var describe = _ref8.describe;
  var extensions = _ref8.extensions;
  var phrase = _ref8.phrase;

  if (describe) {
    var description = describe.call(phrase);
    if (extensions.length) {

      var modifiedDescription = description && _lodash2['default'].merge({}, description, { props: { id: 0 } });
      var extensionElements = _lodash2['default'].map(extensions, function (Extension, index) {
        return (0, _laconaPhrase.createElement)(Extension, _extends({}, phrase.props, { id: index + 1 }));
      });
      description = (0, _laconaPhrase.createElement)(
        'choice',
        null,
        modifiedDescription,
        extensionElements
      );
    }
    return description;
  }
}

function getRealProps(_ref9) {
  var descriptor = _ref9.descriptor;
  var Constructor = _ref9.Constructor;

  var realProps = _lodash2['default'].defaults(descriptor.props || {}, Constructor.defaultProps || {});
  if (descriptor.children && descriptor.children.length > 0) {
    realProps.children = _lodash2['default'].flattenDeep(descriptor.children);
  }
  return realProps;
}

function getConstructor(_ref10) {
  var Constructor = _ref10.Constructor;

  if (_lodash2['default'].isString(Constructor)) {
    if (_lodash2['default'].has(builtins, Constructor)) {
      return builtins[Constructor];
    } else {
      throw new Error(Constructor + ' is an invalid phrase. Note: non-builtin phrases must be uppercase');
    }
  }
  return Constructor;
}

function destroy(_ref11) {
  var phrase = _ref11.phrase;
  var removeSource = _ref11.removeSource;

  if ((phrase.constructor === builtins.choice || phrase.constructor === builtins.sequence) && phrase.childPhrases) {
    phrase.childPhrases.forEach(function (phrase) {
      return destroy({ phrase: phrase, removeSource: removeSource });
    });
  }

  _lodash2['default'].forEach(phrase.__sources, function (_ref12) {
    var source = _ref12.source;
    var descriptor = _ref12.descriptor;

    source.__subscribers--;
    if (source.__subscribers === 0 && source.destroy) {
      source.destroy();
      removeSource(descriptor);
    }
  });

  if (phrase.destroy) phrase.destroy();
}

function create(_ref13) {
  var phrase = _ref13.phrase;

  if (phrase.create) phrase.create();
}

function applySources(_ref14) {
  var sources = _ref14.sources;
  var phrase = _ref14.phrase;
  var getSource = _ref14.getSource;

  phrase.__sources = {};

  _lodash2['default'].forEach(sources, function (descriptor, name) {
    var source = getSource(descriptor);
    source.__subscribers++;
    phrase.__sources[name] = { source: source, lastVersion: 0, descriptor: descriptor };
    _Object$defineProperty(phrase, name, { get: function get() {
        return phrase.__sources[name].source.data;
      } });
  });
}

//TODO debug validation would be nice
// function validate(Constructor) {
//   let hasDefault = false
//   if (!_.every(Constructor.translations, _.partial(_.has, _, 'describe'))) {
//     throw new Error('Every translation must have a describe method')
//   }
//   if (!_.every(Constructor.translations, _.partial(_.has, _, 'langs'))) {
//     throw new Error('Every translation must have a langs property')
//   }
//   if (!_.some(Constructor.translations, translation => _.indexOf(translation.langs, 'default') > -1)) {
//     throw new Error('All elements must have a describe method defined for the default language')
//   }
//   return true
// }