/** @jsx createElement */
'use strict';

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.createOption = createOption;

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _parse2 = require('./parse');

var _parse3 = _interopRequireDefault(_parse2);

var _reconcile = require('./reconcile');

function from(i) {
  var a = [];var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = _getIterator(i), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var x = _step.value;
      a.push(x);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator['return']) {
        _iterator['return']();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return a;
}

var optionDefaults = {
  text: '',
  words: [],
  // match: [],
  // suggestion: [],
  // completion: [],
  // stack: [],
  callbacks: []
  // path: []
};

function createOption(options) {
  return _lodash2['default'].defaults(options, optionDefaults);
}

function normalizeOutput(option) {
  var output = _lodash2['default'].pick(option, ['words', 'score', 'result']);
  // const suggestion = option.suggestion
  // let newSuggestions = []
  // let i, l, lastSuggestion, oldSuggestion

  // if (suggestion.length > 0) {
  //   newSuggestions.push(_.clone(suggestion[0]))
  //   for (i = 1, l = suggestion.length; i < l; i++) {
  //     lastSuggestion = newSuggestions[newSuggestions.length - 1]
  //     oldSuggestion = _.clone(suggestion[i])
  //     if (lastSuggestion.input === oldSuggestion.input && lastSuggestion.category === oldSuggestion.category) {
  //       lastSuggestion.string = lastSuggestion.string + oldSuggestion.string
  //     } else {
  //       newSuggestions.push(oldSuggestion)
  //     }
  //   }
  // }
  // output.suggestion = newSuggestions
  //
  return output;
}

var Parser = (function () {
  function Parser() {
    var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    var _ref$langs = _ref.langs;
    var langs = _ref$langs === undefined ? ['default'] : _ref$langs;
    var grammar = _ref.grammar;
    var _ref$extensions = _ref.extensions;
    var extensions = _ref$extensions === undefined ? [] : _ref$extensions;
    var _ref$reparse = _ref.reparse;
    var reparse = _ref$reparse === undefined ? function () {} : _ref$reparse;

    _classCallCheck(this, Parser);

    this.langs = langs;
    this.grammar = grammar;
    this.extensions = extensions;
    this.reparse = reparse;
    this._currentlyParsing = false;
    this._sources = [];
  }

  _createClass(Parser, [{
    key: '_getExtensions',
    value: function _getExtensions(Constructor) {
      return _lodash2['default'].reduce(this.extensions, function (acc, Extension) {
        if (_lodash2['default'].includes(Extension['extends'], Constructor)) {
          acc.push(Extension);
        }
        return acc;
      }, []);
    }
  }, {
    key: '_getSource',
    value: function _getSource(sourceDescriptor) {
      var _this = this;

      var possibleSource = _lodash2['default'].find(this._sources, function (_ref2) {
        var descriptor = _ref2.descriptor;
        return _lodash2['default'].isEqual(descriptor, sourceDescriptor);
      });
      if (possibleSource) return possibleSource.instance;

      var instance = new sourceDescriptor.Constructor();
      instance.props = sourceDescriptor.props;

      instance.data = {};
      instance.__dataVersion = 0;
      instance.__subscribers = 0;
      instance.setData = function (newData) {
        _lodash2['default'].merge(instance.data, newData);
        instance.__dataVersion++;
        if (!_this._currentlyParsing) _this.reparse();
      };
      instance.replaceData = function (newData) {
        instance.data = newData;
        instance.__dataVersion++;
        if (!_this._currentlyParsing) _this.reparse();
      };

      if (instance.create) instance.create();

      this._sources.push({ instance: instance, descriptor: sourceDescriptor });
      return instance;
    }
  }, {
    key: '_removeSource',
    value: function _removeSource(sourceDescriptor) {
      var index = _lodash2['default'].findIndex(this._sources, function (_ref3) {
        var descriptor = _ref3.descriptor;
        return _lodash2['default'].isEqual(descriptor, sourceDescriptor);
      });
      this._sources.splice(index, 1);
    }
  }, {
    key: 'parse',
    value: _regeneratorRuntime.mark(function parse(inputString) {
      var input, options, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, output;

      return _regeneratorRuntime.wrap(function parse$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            this._currentlyParsing = true;

            if (_lodash2['default'].isString(inputString)) {
              context$2$0.next = 3;
              break;
            }

            throw new Error('lacona parse input must be a string');

          case 3:
            input = createOption({ text: inputString });
            options = {
              langs: this.langs,
              getExtensions: this._getExtensions.bind(this),
              getSource: this._getSource.bind(this),
              removeSource: this._removeSource.bind(this)
            };

            this._phrase = (0, _reconcile.reconcile)({ descriptor: this.grammar, phrase: this._phrase, options: options });

            _iteratorNormalCompletion2 = true;
            _didIteratorError2 = false;
            _iteratorError2 = undefined;
            context$2$0.prev = 9;
            _iterator2 = _getIterator((0, _parse3['default'])({ phrase: this._phrase, input: input, options: options }));

          case 11:
            if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
              context$2$0.next = 20;
              break;
            }

            output = _step2.value;

            if (!(output.text === '')) {
              context$2$0.next = 17;
              break;
            }

            // call each callback (used for limiting)
            output.callbacks.forEach(function (callback) {
              return callback();
            });
            context$2$0.next = 17;
            return normalizeOutput(output);

          case 17:
            _iteratorNormalCompletion2 = true;
            context$2$0.next = 11;
            break;

          case 20:
            context$2$0.next = 26;
            break;

          case 22:
            context$2$0.prev = 22;
            context$2$0.t0 = context$2$0['catch'](9);
            _didIteratorError2 = true;
            _iteratorError2 = context$2$0.t0;

          case 26:
            context$2$0.prev = 26;
            context$2$0.prev = 27;

            if (!_iteratorNormalCompletion2 && _iterator2['return']) {
              _iterator2['return']();
            }

          case 29:
            context$2$0.prev = 29;

            if (!_didIteratorError2) {
              context$2$0.next = 32;
              break;
            }

            throw _iteratorError2;

          case 32:
            return context$2$0.finish(29);

          case 33:
            return context$2$0.finish(26);

          case 34:

            this._currentlyParsing = false;

          case 35:
          case 'end':
            return context$2$0.stop();
        }
      }, parse, this, [[9, 22, 26, 34], [27,, 29, 33]]);
    })
  }, {
    key: 'parseArray',
    value: function parseArray(inputString) {
      return from(this.parse(inputString));
    }
  }]);

  return Parser;
})();

exports['default'] = Parser;