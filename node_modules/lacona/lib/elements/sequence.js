/** @jsx createElement */
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _defineProperty = require('babel-runtime/helpers/define-property')['default'];

var _extends = require('babel-runtime/helpers/extends')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _laconaPhrase = require('lacona-phrase');

var _parse = require('../parse');

var _parse2 = _interopRequireDefault(_parse);

var _reconcile = require('../reconcile');

// function addSeparator (child, separator) {
//   if (child.props && child.props.optional) {
//     const newChild = _.merge({}, child, {props: {optional: false}})
//     //TODO there are likely some problems with separators and optional
//     return <Sequence optional={true} merge={true}>{newChild}{separator}</Sequence>
//   } else {
//     return <Sequence merge={true}>{child}{separator}</Sequence>
//   }
// }

var Sequence = (function (_Phrase) {
  _inherits(Sequence, _Phrase);

  function Sequence() {
    _classCallCheck(this, Sequence);

    _get(Object.getPrototypeOf(Sequence.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(Sequence, [{
    key: 'describe',
    value: function describe() {
      //replace optionals with replacements
      if (_lodash2['default'].some(this.props.children, _lodash2['default'].property('props.optional'))) {
        var newChildren = _lodash2['default'].map(this.props.children, function (child) {
          if (child && child.props && child.props.optional) {

            var newChild = _lodash2['default'].merge({}, child, { props: { optional: false } });
            delete newChild.props.id;
            delete newChild.props.merge;

            var choiceChildren = [(0, _laconaPhrase.createElement)('literal', { text: '' }), newChild];

            if (child.props.preferred) choiceChildren.reverse();

            return (0, _laconaPhrase.createElement)(
              'choice',
              { limit: child.props.limited ? 1 : undefined, id: child.props.id, merge: child.props.merge },
              choiceChildren
            );
          }

          return child;
        });

        return (0, _laconaPhrase.createElement)(
          'sequence',
          _extends({}, this.props, { children: undefined }),
          newChildren
        );
      }
    }
  }, {
    key: '_handleParse',
    value: _regeneratorRuntime.mark(function _handleParse(input, options) {
      var modifications;
      return _regeneratorRuntime.wrap(function _handleParse$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            this.childPhrases = (0, _reconcile.reconcile)({ descriptor: this.props.children, phrase: this.childPhrases, options: options });

            modifications = {
              result: {},
              score: 1
            };
            return context$2$0.delegateYield(this.parseChild(0, _lodash2['default'].assign({}, input, modifications), options), 't0', 3);

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, _handleParse, this);
    })
  }, {
    key: 'parseChild',
    value: _regeneratorRuntime.mark(function parseChild(childIndex, input, options) {
      var child, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, output, accumulatedResult, newScore, nextOutput;

      return _regeneratorRuntime.wrap(function parseChild$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (!(childIndex >= this.childPhrases.length)) {
              context$2$0.next = 4;
              break;
            }

            context$2$0.next = 3;
            return input;

          case 3:
            return context$2$0.abrupt('return');

          case 4:
            child = this.childPhrases[childIndex];
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _iteratorError = undefined;
            context$2$0.prev = 8;
            _iterator = _getIterator((0, _parse2['default'])({ phrase: this.childPhrases[childIndex], input: input, options: options }));

          case 10:
            if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
              context$2$0.next = 21;
              break;
            }

            output = _step.value;

            if (!(this.props.unique && output.result != null && child.props.id && input.result[child.props.id] != null)) {
              context$2$0.next = 14;
              break;
            }

            return context$2$0.abrupt('continue', 18);

          case 14:
            accumulatedResult = this.props.value || getAccumulatedResult(input.result, child, output.result);
            newScore = input.score * output.score;
            nextOutput = _lodash2['default'].assign({}, output, {
              result: accumulatedResult,
              score: newScore
            });
            return context$2$0.delegateYield(this.parseChild(childIndex + 1, nextOutput, options), 't0', 18);

          case 18:
            _iteratorNormalCompletion = true;
            context$2$0.next = 10;
            break;

          case 21:
            context$2$0.next = 27;
            break;

          case 23:
            context$2$0.prev = 23;
            context$2$0.t1 = context$2$0['catch'](8);
            _didIteratorError = true;
            _iteratorError = context$2$0.t1;

          case 27:
            context$2$0.prev = 27;
            context$2$0.prev = 28;

            if (!_iteratorNormalCompletion && _iterator['return']) {
              _iterator['return']();
            }

          case 30:
            context$2$0.prev = 30;

            if (!_didIteratorError) {
              context$2$0.next = 33;
              break;
            }

            throw _iteratorError;

          case 33:
            return context$2$0.finish(30);

          case 34:
            return context$2$0.finish(27);

          case 35:
          case 'end':
            return context$2$0.stop();
        }
      }, parseChild, this, [[8, 23, 27, 35], [28,, 30, 34]]);
    })
  }]);

  return Sequence;
})(_laconaPhrase.Phrase);

exports['default'] = Sequence;

function getAccumulatedResult(inputResult, child, childResult) {
  if (!_lodash2['default'].isUndefined(childResult)) {
    var childId = child.props.id;
    var childMerge = child.props.merge;
    if (childId) {
      return _lodash2['default'].assign({}, inputResult, _defineProperty({}, childId, childResult));
    } else if (childMerge) {
      if (_lodash2['default'].isPlainObject(childResult)) {
        return _lodash2['default'].merge({}, inputResult, childResult);
      } else {
        return childResult;
      }
    }
  }
  return inputResult;
}
module.exports = exports['default'];