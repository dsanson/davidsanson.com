'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

// import {handleString} from '../input-option'

var _laconaPhrase = require('lacona-phrase');

var _stackfindJs = require('../stackfind.js');

var _stackfindJs2 = _interopRequireDefault(_stackfindJs);

var Value = (function (_Phrase) {
  _inherits(Value, _Phrase);

  function Value() {
    _classCallCheck(this, Value);

    _get(Object.getPrototypeOf(Value.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(Value, [{
    key: '_handleParse',
    value: _regeneratorRuntime.mark(function _handleParse(input, options) {
      var successes, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, output, success, modification, word, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2;

      return _regeneratorRuntime.wrap(function _handleParse$(context$2$0) {
        var _this = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            successes = 0;

            if (!(input.text === '')) {
              context$2$0.next = 39;
              break;
            }

            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _iteratorError = undefined;
            context$2$0.prev = 5;
            _iterator = _getIterator(this.props.suggest());

          case 7:
            if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
              context$2$0.next = 23;
              break;
            }

            output = _step.value;
            success = false;
            modification = {
              result: output.value,
              score: output.score || 1
            };

            if (this.props.limit) modification.callbacks = input.callbacks.concat(function () {
              return success = true;
            });

            word = {
              text: output.text,
              // category,
              input: false,
              argument: input.currentArgument,
              category: this.props.category
              // qualifier,
              // descriptors
            };

            modification.words = input.words.concat(word);

            // if (_.isEmpty(input.suggestion)) {
            //   modification.suggestion = input.suggestion.concat(word)
            // } else {
            //   modification.completion = input.completion.concat(word)
            // }
            //
            context$2$0.next = 16;
            return _lodash2['default'].assign({}, input, modification);

          case 16:
            if (!this.props.limit) {
              context$2$0.next = 20;
              break;
            }

            if (success) successes++;

            if (!(this.props.limit <= successes)) {
              context$2$0.next = 20;
              break;
            }

            return context$2$0.abrupt('break', 23);

          case 20:
            _iteratorNormalCompletion = true;
            context$2$0.next = 7;
            break;

          case 23:
            context$2$0.next = 29;
            break;

          case 25:
            context$2$0.prev = 25;
            context$2$0.t0 = context$2$0['catch'](5);
            _didIteratorError = true;
            _iteratorError = context$2$0.t0;

          case 29:
            context$2$0.prev = 29;
            context$2$0.prev = 30;

            if (!_iteratorNormalCompletion && _iterator['return']) {
              _iterator['return']();
            }

          case 32:
            context$2$0.prev = 32;

            if (!_didIteratorError) {
              context$2$0.next = 35;
              break;
            }

            throw _iteratorError;

          case 35:
            return context$2$0.finish(32);

          case 36:
            return context$2$0.finish(29);

          case 37:
            context$2$0.next = 72;
            break;

          case 39:
            _iteratorNormalCompletion2 = true;
            _didIteratorError2 = false;
            _iteratorError2 = undefined;
            context$2$0.prev = 42;
            _iterator2 = _getIterator(this.props.compute(input.text));

          case 44:
            if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
              context$2$0.next = 58;
              break;
            }

            output = _step2.value;
            success = false;
            modification = {
              result: output.value,
              score: output.score || 1,
              text: output.remaining,
              words: input.words.concat(_lodash2['default'].map(output.words, function (word) {
                return _lodash2['default'].assign(word, {
                  argument: input.currentArgument,
                  category: _this.props.category
                });
              }))
            };

            if (this.props.limit) modification.callbacks = input.callbacks.concat(function () {
              return success = true;
            });
            //
            // const trueWords = output.words.map(word => ({
            //   text: word.text,
            //   // category,
            //   input: word.input
            //   // qualifier: word.qualifier || qualifier,
            //   // descriptors
            // }))

            // modification.words = output.words

            // if (_.isEmpty(input.suggestion) && (_.every(output.words, 'input') || output.decorator)) {
            //   modification.match = input.match.concat(trueWords)
            // } else {
            //   modification.suggestion = input.suggestion.concat(trueWords)
            // }

            context$2$0.next = 51;
            return _lodash2['default'].assign({}, input, modification);

          case 51:
            if (!this.props.limit) {
              context$2$0.next = 55;
              break;
            }

            if (success) successes++;

            if (!(this.props.limit <= successes)) {
              context$2$0.next = 55;
              break;
            }

            return context$2$0.abrupt('break', 58);

          case 55:
            _iteratorNormalCompletion2 = true;
            context$2$0.next = 44;
            break;

          case 58:
            context$2$0.next = 64;
            break;

          case 60:
            context$2$0.prev = 60;
            context$2$0.t1 = context$2$0['catch'](42);
            _didIteratorError2 = true;
            _iteratorError2 = context$2$0.t1;

          case 64:
            context$2$0.prev = 64;
            context$2$0.prev = 65;

            if (!_iteratorNormalCompletion2 && _iterator2['return']) {
              _iterator2['return']();
            }

          case 67:
            context$2$0.prev = 67;

            if (!_didIteratorError2) {
              context$2$0.next = 70;
              break;
            }

            throw _iteratorError2;

          case 70:
            return context$2$0.finish(67);

          case 71:
            return context$2$0.finish(64);

          case 72:
          case 'end':
            return context$2$0.stop();
        }
      }, _handleParse, this, [[5, 25, 29, 37], [30,, 32, 36], [42, 60, 64, 72], [65,, 67, 71]]);
    })
  }]);

  return Value;
})(_laconaPhrase.Phrase);

exports['default'] = Value;

Value.defaultProps = {
  suggest: function suggest() {
    return [];
  },
  compute: function compute() {
    return [];
  }
};
module.exports = exports['default'];

// if this has a category use that, else the last category on the stack
// const category = stackFind(input.stack, 'category', this.props.category, null)
// const qualifier = stackFind(input.stack, 'qualifier', this.props.qualifier, null)
// const descriptors = _.chain(input.stack).map('descriptor').filter().value()

// TODO this is **super** WET